# Задача 1: Диаграмма компонентов
![С41-Страница — 3](https://github.com/NikitaBushmakin/PAPSWORK/assets/164217929/6c3b2196-1013-4d3e-83b9-50142a91b93b)

Спускаемся на уровень диаграммы компонентов. Веб-приложение состоит из 3х частей:
- Компонент, отвечающий за авторизацию. Содержит в себе экран авторизации и логику, необходимую для его работы и для запросов к сервису авторизации. 
- Компонент, отвечающий за вызов медработника, позволяющий пользователю запросить вызов. Вызов перенаправляется в сервис вызова медработника.
- Компонент, отвечающий за чат. Позволяет вызванному медработнику и вызвавшему его пациенту переписываться между собой.

Комментарий: сюда, наверное, следует добавить еще и компонент для регистрации, который тоже ссылается на сервис авторизации.

# Задача 2: Диаграмма последовательностей
![С41-Страница — 4](https://github.com/NikitaBushmakin/PAPSWORK/assets/164217929/950e552c-f7de-4c86-b784-b66fe2f65196)

# Задача 3: Схема БД
![С41-Страница — 5 (4)](https://github.com/NikitaBushmakin/PAPSWORK/assets/164217929/e8a7a722-978d-4347-b3f0-3f829c951286)

*Поправить: Надо разделить хранение истории болезни и заметок медработника, чтобы выполнялся принцип единственной ответственности.

# Задача 4: Расписать принципы
**YAGNI**

Пример: Добавление функционала оценки репутации пациентов, чтобы отсеивать тех, кто совершает ложные вызовы. Это не является функционалом первой значимости, а потому не будет реализовано при создании первых версий системы. Еще одним примером может послужить назначение пользователя медработником. В первых версиях системы это вполне допустимо делать, напрямую взаимодействуя с БД, а не создавая отдельный функционал.


**DRY**

Пример: Добавление функционала авторизации, регистрации пользователей, хранение данных о пользователях в БД. Поскольку этот функционал, по большей части, совпадает у пациентов и медработников, не требуется писать отдельные функции для его реализации и создавать отдельные таблицы БД для хранения данных пациентов и медработников.


**KISS**

Пример: Интерфейс окна авторизации. Не нужно делать слишком красивое оформление и много пунктов. Для выполнения функционала достаточно лишь наличие двух полей ввода (для логина и пароля), кнопки "Вход" и места, куда можно будет вывести сообщение об ошибке. Возможно, понадобится еще и кнопка "Регистрация".


**SOLID**
- S (Single Responsibility Principle). Пример: работа с историей болезни пациента и с заметками медработника по поводу прошлых консультаций. Хотя есть соблазн сделать это через единый класс и единую таблицу в БД, лучше сделать это раздельно. Для истории болезни не понадобится, например, хранить дату создания и медработника, написавшего её.
- O (Open/Closed Principle). Пример: Потенциальная потребность в дополнении системы новыми типами пользователей, кроме пациента и медработника. Например, добавление администратора для отладки внутренних функций системы. Новый класс пользователя будет отнаследован от общего класса пользователя, чтобы не перезаписывать функции, используемые уже существующие пациентом и медработником.
- L (Liskov Substitution Principle). Пример: Замена общего "пользователя" либо пациентом, либо медработником. Объекты одного типа должны быть заменяемы объектами подтипов без изменения свойств программы: Замена базового объекта на его подклассы не должна менять поведение программы. Использование интерфейсов или абстрактных классов для предметов, чтобы различные типы предметов могли быть легко заменены другими типами без нарушения функциональности расписания.
- I (Interface Segregation Principle). Пример: Разделение интерфейсов для работы с медсотрудниками и пациентами. Много специализированных интерфейсов лучше, чем один универсальный: Классы не должны зависеть от методов, которые им не нужны. Так, например, пациент не должен иметь доступ к запросам заметок, истории болезни и к работе с базой знаний, а медработник не должен иметь возможности запросить консультации медработника. Реализовано это будет с помощью создания отдельных интерфейсов для каждой роли пользователя, которые будут иметь свои специфические классы и функции.
- D (Dependency Inversion Principle). Пример: Работа с базой данных через абстрактный интерфейс. Зависимости должны быть от абстракций, а не от конкретики: Код не должен зависеть от конкретной реализации, а от абстрактных интерфейсов. Использование паттернов зависимости и внедрения зависимостей (Dependency Injection), чтобы классы не зависели напрямую от конкретной базы данных, а работали через абстрактный интерфейс для доступа к данным.
